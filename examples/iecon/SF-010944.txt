In a lockstep system, errors induced by single-point and common-mode failures could cause catastrophic fatality without proper error detection or write-protection circuitries. In this paper, we design and implement a dual lockstep processor using a two pipelined assembly that executes two virtual cores each, in an interleaved fashion. Such an approach could overcome common-mode failures (CMFs). Furthermore, by running the same code in a secondary pipeline, our system can detect a single-point-of-failure (SPOF). Our technique easily maintains the synchronization between the two virtual cores and omits other fabric that binds a typical dual-core lockstep processor. This reduces the die size and provides early error detection before an error becomes unrecoverable. We achieve our goal by incorporating the lockstep function in the micro-architecture and employing fine-grained multitasking to increase a systemâ€™s fail-safe capabilities. Finally, we validate our lockstep processor using the RISC-V 32IM ISA test benches, Dhrystones and Coremark benchmarks, and ModelSim. Our results show a 100% self-checking coverage for stuck-at faults and complete error containment. Since our framework operates fine-grained multitasking, we achieve two lockstep processors instead of one, which saves hardware costs. 
